# CS300
Coursework for CS300

What was the problem you were solving in the projects for this course?
The problem across all of these projects was figuring out how to manage and access course or bid data efficiently. Each assignment gave me practice with a new data structure (vectors, linked lists, hash tables, and binary search trees) and the final project tied it all together in the form of the ABCU advising program. The main challenge was to store courses in a way that made it easy to list them in order and to quickly find details like prerequisites.

How did you approach the problem?
I approached it by first breaking the requirements into smaller steps and mapping them to the right data structure. For example, I used a binary search tree because of its efficiency in searching and sorting data. Understanding data structures was important because each one changes how fast and how easily you can insert, search, or remove information. Instead of focusing only on “getting it to work,” I had to think about efficiency and organization.

How did you overcome any roadblocks you encountered?
The main roadblocks came from small implementation details like handling pointers correctly, remembering when nodes were value types versus dynamically allocated, and making sure special cases like deleting a root node were handled properly. I overcame those challenges by carefully stepping through the logic, comparing it to the pseudocode I wrote earlier, and sometimes rewriting methods to more closely mirror my earlier working code. Testing along the way by loading data, adding a new course, searching, and removing, helped confirm that each function worked as expected.

How has your work on this project expanded your approach to designing software and developing programs?
This project made me think more like a designer and less like just a coder. I started to see the importance of planning ahead with pseudocode, analyzing runtime, and then coding in a way that matches the design. It showed me that the right data structure can make or break a program, especially when the program grows to thousands of records.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
Working through these projects pushed me to write cleaner, more modular code. I now use consistent naming conventions, add comments that explain “why” and not just “what,” and keep each method focused on a single job. I also paid attention to handling user input and error cases gracefully, since the final program needed to be usable by non-technical advisors. Altogether, I’m leaving this course with stronger habits that will help me write programs that are easier to understand, maintain, and adapt in the future.
